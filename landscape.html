#!/usr/bin/env python3
# gex_web.py
#
# One-file FastAPI backend for MVP dashboard + landscape + chart page.
# - Expiry dropdown via /api/expiries
# - Main data via /api/mvp?symbol=$SPX&expiry=YYYY-MM-DD:DTE&strike_count=60
# - Adds maxchange (largest delta-by-strike shift) for 1m/5m/15m
#
# IMPORTANT: Public errors do NOT mention upstream/provider names.

from __future__ import annotations

import json
import time
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Dict, List, Optional, Tuple

import requests
from fastapi import FastAPI, Query
from fastapi.responses import FileResponse, JSONResponse, HTMLResponse
from fastapi.staticfiles import StaticFiles

# ----------------------------
# Config (paths + limits)
# ----------------------------
BASE_DIR = Path(__file__).resolve().parent

INDEX_HTML = BASE_DIR / "index.html"
LANDSCAPE_HTML = BASE_DIR / "landscape.html"

# NEW: chart page (support both names + static/)
CHART_HTML = BASE_DIR / "chart.html"
CHARTS_HTML = BASE_DIR / "charts.html"
STATIC_DIR = BASE_DIR / "static"
STATIC_CHART = STATIC_DIR / "chart.html"

# Token file you already have:
TOKEN_FILE = BASE_DIR / "schwab_tokens_schwab_lib.json"

# Optional app creds file (needed only if you want auto-refresh)
# Format: {"client_id":"...","client_secret":"..."}
CRED_FILE = BASE_DIR / "schwab_app.json"

CHAIN_URL = "https://api.schwabapi.com/marketdata/v1/chains"

# Avoid payload overflow
DEFAULT_RANGE = "NTM"
MAX_STRIKECOUNT_HARD = 90  # hard clamp

# Caching
CACHE_TTL_SEC = 3          # chain snapshot cache (short)
EXPIRY_TTL_SEC = 90        # expiries cache

# Snapshot history for maxchange
HISTORY_MAX_POINTS = 300       # enough for ~15 minutes at 3s refresh (300*3s=900s)
HISTORY_MAX_AGE_SEC = 60 * 35  # keep up to 35 minutes


@dataclass
class CacheItem:
    t: float
    data: dict


_CHAIN_CACHE: Dict[Tuple[str, str, int], CacheItem] = {}
_EXPIRY_CACHE: Dict[Tuple[str, int], CacheItem] = {}

# For maxchange: (symbol, expiry, strike_count) -> list[(ts, gex_oi_list)]
_HISTORY: Dict[Tuple[str, str, int], List[Tuple[float, List[int]]]] = {}

# ----------------------------
# App
# ----------------------------
app = FastAPI(title="GEX MVP", version="1.0")

if STATIC_DIR.exists():
    app.mount("/static", StaticFiles(directory=str(STATIC_DIR)), name="static")


@app.get("/")
def root():
    if INDEX_HTML.exists():
        return FileResponse(str(INDEX_HTML))
    return JSONResponse({"ok": False, "error": "index.html not found"}, status_code=404)


@app.get("/landscape")
def landscape():
    if LANDSCAPE_HTML.exists():
        return FileResponse(str(LANDSCAPE_HTML))
    return JSONResponse({"ok": False, "error": "landscape.html not found"}, status_code=404)


# NEW: /chart route
@app.get("/chart")
def chart():
    """
    Independent chart page (TradingView iframe + overlay).
    Supports these file locations:
      - /root/ironcondor/chart.html
      - /root/ironcondor/charts.html
      - /root/ironcondor/static/chart.html
    """
    if CHART_HTML.exists():
        return FileResponse(str(CHART_HTML), media_type="text/html")
    if CHARTS_HTML.exists():
        return FileResponse(str(CHARTS_HTML), media_type="text/html")
    if STATIC_CHART.exists():
        return FileResponse(str(STATIC_CHART), media_type="text/html")

    return HTMLResponse(
        "<html><body style='font-family:system-ui;background:#0b1020;color:#e7eefc;padding:24px'>"
        "<h2>Chart page not found</h2>"
        "<p>Create one of the following:</p>"
        f"<ul><li>{CHART_HTML}</li><li>{CHARTS_HTML}</li><li>{STATIC_CHART}</li></ul>"
        "</body></html>",
        status_code=404,
    )


@app.get("/api/ping")
def ping():
    return {"ok": True, "ts": int(time.time())}


# ----------------------------
# Token handling
# ----------------------------
def _load_token_doc() -> dict:
    if not TOKEN_FILE.exists():
        raise RuntimeError(f"Missing token file: {TOKEN_FILE}")
    return json.loads(TOKEN_FILE.read_text(encoding="utf-8"))


def _token_fields(doc: dict) -> dict:
    # Your file structure: { "token": { "access_token":..., "refresh_token":..., "expires_at":... }, ... }
    return doc.get("token") or {}


def _is_access_expired(tok: dict) -> bool:
    exp = tok.get("expires_at")
    if not exp:
        return False
    try:
        return time.time() >= float(exp) - 15
    except Exception:
        return False


def _load_app_creds() -> Tuple[str, str]:
    if not CRED_FILE.exists():
        raise RuntimeError(f"Missing creds file: {CRED_FILE}")
    j = json.loads(CRED_FILE.read_text(encoding="utf-8"))
    cid = (j.get("client_id") or "").strip()
    csec = (j.get("client_secret") or "").strip()
    if not cid or not csec:
        raise RuntimeError("Creds file missing client_id/client_secret.")
    return cid, csec


def _refresh_access_token(doc: dict) -> dict:
    tok = _token_fields(doc)
    rtoken = tok.get("refresh_token")
    if not rtoken:
        raise RuntimeError("Missing refresh_token in token file.")

    cid, csec = _load_app_creds()

    token_url = "https://api.schwabapi.com/v1/oauth/token"
    auth = requests.auth.HTTPBasicAuth(cid, csec)
    data = {"grant_type": "refresh_token", "refresh_token": rtoken}

    r = requests.post(token_url, auth=auth, data=data, timeout=20)
    if r.status_code != 200:
        raise RuntimeError(f"Token refresh failed ({r.status_code})")

    new_tok = r.json()
    expires_in = int(new_tok.get("expires_in", 1800))

    new_doc = dict(doc)
    new_doc["token"] = dict(tok)
    new_doc["token"]["access_token"] = new_tok.get("access_token", tok.get("access_token"))
    new_doc["token"]["token_type"] = new_tok.get("token_type", tok.get("token_type", "Bearer"))
    new_doc["token"]["scope"] = new_tok.get("scope", tok.get("scope", "api"))
    new_doc["token"]["expires_in"] = expires_in
    new_doc["token"]["expires_at"] = int(time.time()) + expires_in
    if new_tok.get("refresh_token"):
        new_doc["token"]["refresh_token"] = new_tok["refresh_token"]

    TOKEN_FILE.write_text(json.dumps(new_doc, indent=2), encoding="utf-8")
    return new_doc


def _get_access_token() -> str:
    doc = _load_token_doc()
    tok = _token_fields(doc)

    if _is_access_expired(tok):
        try:
            doc = _refresh_access_token(doc)
            tok = _token_fields(doc)
        except Exception:
            exp = tok.get("expires_at")
            hint = f"Token expires_at={exp}" if exp else "Token expired"
            raise RuntimeError("Token expired. Update your token file (manual) then reload. " + hint)

    access = (tok.get("access_token") or "").strip()
    if not access:
        raise RuntimeError("Missing access token in token file.")
    return access


# ----------------------------
# Chain fetching + parsing
# ----------------------------
def _request_chain(symbol: str, strike_count: int, range_name: str) -> dict:
    access = _get_access_token()
    headers = {"Authorization": f"Bearer {access}"}
    params = {
        "symbol": symbol,
        "strikeCount": strike_count,
        "includeUnderlyingQuote": "TRUE",
        "strategy": "SINGLE",
        "range": range_name,
    }
    r = requests.get(CHAIN_URL, headers=headers, params=params, timeout=25)
    if r.status_code != 200:
        # keep message generic
        raise RuntimeError(f"Chain fetch failed: {r.status_code}")
    return r.json()


def _extract_expiry_keys(chain: dict) -> List[str]:
    call_map = chain.get("callExpDateMap") or {}
    put_map = chain.get("putExpDateMap") or {}
    keys = set(call_map.keys()) | set(put_map.keys())

    def sort_key(k: str):
        try:
            d, dte = k.split(":")
            return (d, int(dte))
        except Exception:
            return (k, 999999)

    return sorted(keys, key=sort_key)


def _pick_expiry(keys: List[str], dte: int, mode: str) -> str:
    if not keys:
        raise RuntimeError("No expiries in chain.")

    def dte_of(k: str) -> int:
        try:
            return int(k.split(":")[1])
        except Exception:
            return 10**9

    keys_sorted = sorted(keys, key=lambda k: abs(dte_of(k) - int(dte)))
    if mode == "next":
        best = keys_sorted[0]
        best_dte = dte_of(best)
        later = [k for k in keys if dte_of(k) > best_dte]
        if later:
            return sorted(later, key=dte_of)[0]
        return best
    return keys_sorted[0]


def _iter_strikes(exp_map: dict) -> List[float]:
    out = []
    for strike_str in exp_map.keys():
        try:
            out.append(float(strike_str))
        except Exception:
            pass
    return sorted(out)


def _get_contract(exp_map: dict, strike: float) -> Optional[dict]:
    k = f"{strike:.1f}"
    if k not in exp_map:
        k2 = str(int(strike)) if float(strike).is_integer() else str(strike)
        if k2 in exp_map:
            k = k2
        else:
            for kk in exp_map.keys():
                try:
                    if abs(float(kk) - strike) < 1e-6:
                        k = kk
                        break
                except Exception:
                    continue
            else:
                return None

    arr = exp_map.get(k) or []
    if not arr:
        return None
    return arr[0]


def _mid(bid: Any, ask: Any, mark: Any) -> float:
    try:
        if mark is not None and float(mark) > 0:
            return float(mark)
    except Exception:
        pass
    try:
        b = float(bid) if bid is not None else 0.0
        a = float(ask) if ask is not None else 0.0
        if b > 0 and a > 0:
            return (b + a) / 2.0
        if a > 0:
            return a
        return b
    except Exception:
        return 0.0


def _safe_int(x: Any) -> int:
    try:
        return int(float(x))
    except Exception:
        return 0


def _safe_float(x: Any) -> float:
    try:
        return float(x)
    except Exception:
        return 0.0


# ----------------------------
# Maxchange helpers
# ----------------------------
def _prune_history(key: Tuple[str, str, int]) -> None:
    rows = _HISTORY.get(key)
    if not rows:
        return
    now = time.time()
    rows = [(ts, v) for (ts, v) in rows if (now - ts) <= HISTORY_MAX_AGE_SEC]
    if len(rows) > HISTORY_MAX_POINTS:
        rows = rows[-HISTORY_MAX_POINTS:]
    _HISTORY[key] = rows


def _push_history(key: Tuple[str, str, int], gex_oi: List[int]) -> None:
    now = time.time()
    rows = _HISTORY.get(key) or []
    rows.append((now, list(gex_oi)))
    _HISTORY[key] = rows
    _prune_history(key)


def _snapshot_at_or_before(key: Tuple[str, str, int], seconds_ago: int) -> Optional[List[int]]:
    rows = _HISTORY.get(key) or []
    if not rows:
        return None
    target = time.time() - seconds_ago
    cand = None
    for ts, vals in rows:
        if ts <= target:
            cand = vals
        else:
            break
    return cand


def _compute_maxchange_payload(strikes: List[float], current: List[int], past: List[int]) -> dict:
    best_i = None
    best_abs = -1
    best_delta = 0
    for i in range(min(len(current), len(past))):
        d = int(current[i]) - int(past[i])
        ad = abs(d)
        if ad > best_abs:
            best_abs = ad
            best_i = i
            best_delta = d
    if best_i is None:
        return {}
    return {"strike": float(strikes[best_i]), "delta": int(best_delta)}


def _compute_maxchange(key: Tuple[str, str, int], strikes: List[float], gex_oi: List[int]) -> Tuple[dict, dict]:
    """
    Returns:
      maxchange: {"1m":{...},"5m":{...},"15m":{...}}
      flips: {"1m":bool,"5m":bool,"15m":bool}
    """
    windows = {"1m": 60, "5m": 300, "15m": 900}
    out = {}
    flips = {}
    for label, sec in windows.items():
        past = _snapshot_at_or_before(key, sec)
        if not past:
            out[label] = {}
            flips[label] = False
            continue
        mc = _compute_maxchange_payload(strikes, gex_oi, past)
        out[label] = mc
        flips[label] = False

    # simple flip heuristic
    try:
        if out["1m"] and out["5m"]:
            flips["1m"] = (out["1m"]["delta"] > 0 and out["5m"]["delta"] < 0) or (out["1m"]["delta"] < 0 and out["5m"]["delta"] > 0)
    except Exception:
        pass
    return out, flips


# ----------------------------
# Snapshot computation
# ----------------------------
def _compute_snapshot(symbol: str, expiry_key: str, strike_count: int) -> dict:
    cache_key = (symbol, expiry_key, strike_count)
    hit = _CHAIN_CACHE.get(cache_key)

    # IMPORTANT: use "<" not "<=" so a 3s sleep won't get stuck hitting cache forever
    if hit and (time.time() - hit.t) < CACHE_TTL_SEC:
        out = dict(hit.data)
        out["cache"] = {"hit": True}
        out["server_time"] = int(time.time())
        return out

    chain = _request_chain(symbol=symbol, strike_count=strike_count, range_name=DEFAULT_RANGE)

    spot = _safe_float(chain.get("underlyingPrice") or chain.get("underlying", {}).get("mark"))
    call_map_all = chain.get("callExpDateMap") or {}
    put_map_all = chain.get("putExpDateMap") or {}

    if expiry_key not in call_map_all and expiry_key not in put_map_all:
        chain = _request_chain(symbol=symbol, strike_count=min(strike_count, 40), range_name="ALL")
        call_map_all = chain.get("callExpDateMap") or {}
        put_map_all = chain.get("putExpDateMap") or {}
        spot = _safe_float(chain.get("underlyingPrice") or chain.get("underlying", {}).get("mark"))

    if expiry_key not in call_map_all and expiry_key not in put_map_all:
        raise RuntimeError("Could not find selected expiry in chain payload.")

    call_map = call_map_all.get(expiry_key) or {}
    put_map = put_map_all.get(expiry_key) or {}

    strikes = sorted(set(_iter_strikes(call_map) + _iter_strikes(put_map)))
    if not strikes:
        raise RuntimeError("No strikes for selected expiry.")

    atm_strike = min(strikes, key=lambda s: abs(s - spot)) if spot else strikes[len(strikes) // 2]
    c_atm = _get_contract(call_map, atm_strike) or {}
    p_atm = _get_contract(put_map, atm_strike) or {}

    atm_call_mid = _mid(c_atm.get("bid"), c_atm.get("ask"), c_atm.get("mark"))
    atm_put_mid = _mid(p_atm.get("bid"), p_atm.get("ask"), p_atm.get("mark"))

    expected_move = float(atm_call_mid + atm_put_mid)
    em_lower = spot - expected_move
    em_upper = spot + expected_move

    gex_oi: List[int] = []
    gex_vol: List[int] = []

    call_wall = None
    put_wall = None
    max_call_oi = -1
    max_put_oi = -1

    for s in strikes:
        c = _get_contract(call_map, s) or {}
        p = _get_contract(put_map, s) or {}

        c_oi = _safe_int(c.get("openInterest"))
        p_oi = _safe_int(p.get("openInterest"))
        c_v = _safe_int(c.get("totalVolume"))
        p_v = _safe_int(p.get("totalVolume"))

        net_oi = c_oi - p_oi
        net_vol = c_v - p_v

        gex_oi.append(net_oi)
        gex_vol.append(net_vol)

        if c_oi > max_call_oi:
            max_call_oi = c_oi
            call_wall = s
        if p_oi > max_put_oi:
            max_put_oi = p_oi
            put_wall = s

    # zero pivot estimate
    zero_gamma = None
    idx_spot = min(range(len(strikes)), key=lambda i: abs(strikes[i] - spot)) if spot else len(strikes) // 2
    best_abs = 10**18
    best_strike = strikes[idx_spot]
    for i, s in enumerate(strikes):
        aa = abs(gex_oi[i])
        if aa < best_abs:
            best_abs = aa
            best_strike = s

    for i in range(1, len(strikes)):
        if (gex_oi[i - 1] <= 0 <= gex_oi[i]) or (gex_oi[i - 1] >= 0 >= gex_oi[i]):
            cand = strikes[i] if abs(strikes[i] - spot) < abs(strikes[i - 1] - spot) else strikes[i - 1]
            if zero_gamma is None or abs(cand - spot) < abs(zero_gamma - spot):
                zero_gamma = cand
    if zero_gamma is None:
        zero_gamma = best_strike

    # push history and compute maxchange
    hist_key = (symbol, expiry_key, strike_count)
    _push_history(hist_key, gex_oi)
    maxchange, flips = _compute_maxchange(hist_key, strikes, gex_oi)

    out = {
        "live": True,
        "symbol": symbol,
        "expiry": expiry_key,
        "spot": round(spot, 2),
        "atm_strike": float(atm_strike),
        "atm_call_mid": round(atm_call_mid, 4),
        "atm_put_mid": round(atm_put_mid, 4),
        "expected_move": round(expected_move, 2),
        "em_lower": round(em_lower, 2),
        "em_upper": round(em_upper, 2),
        "call_wall": float(call_wall) if call_wall is not None else None,
        "put_wall": float(put_wall) if put_wall is not None else None,
        "zero_gamma": float(zero_gamma) if zero_gamma is not None else None,
        "histogram": {
            "strikes": [float(x) for x in strikes],
            "gex_oi": gex_oi,
            "gex_vol": gex_vol,
        },
        "maxchange": maxchange,
        "maxchange_flips": flips,
        "unusual": [],
        "cache": {"hit": False},
        "server_time": int(time.time()),
    }

    _CHAIN_CACHE[cache_key] = CacheItem(t=time.time(), data=out)
    return out


# ----------------------------
# Public APIs
# ----------------------------
@app.get("/api/expiries")
def api_expiries(
    symbol: str = Query("$SPX"),
    limit: int = Query(8, ge=1, le=12),
):
    symbol = (symbol or "").strip() or "$SPX"
    ck = (symbol, limit)
    hit = _EXPIRY_CACHE.get(ck)
    if hit and (time.time() - hit.t) <= EXPIRY_TTL_SEC:
        out = dict(hit.data)
        out["cache"] = {"hit": True}
        return out

    chain = _request_chain(symbol=symbol, strike_count=10, range_name=DEFAULT_RANGE)
    keys = _extract_expiry_keys(chain)[:limit]
    out = {"symbol": symbol, "expiries": keys, "cache": {"hit": False}}
    _EXPIRY_CACHE[ck] = CacheItem(t=time.time(), data=out)
    return out


@app.get("/api/mvp")
def api_mvp(
    symbol: str = Query("$SPX"),
    strike_count: int = Query(60, ge=10, le=200),
    expiry: Optional[str] = Query(None),  # explicit key: "YYYY-MM-DD:DTE"
    # keep these for compatibility, but dashboard can hide them
    dte: int = Query(0, ge=0, le=365),
    expiry_mode: str = Query("closest"),
):
    symbol = (symbol or "").strip() or "$SPX"
    strike_count = int(min(max(strike_count, 10), MAX_STRIKECOUNT_HARD))

    try:
        if expiry and isinstance(expiry, str) and ":" in expiry:
            expiry_key = expiry.strip()
        else:
            chain = _request_chain(symbol=symbol, strike_count=10, range_name=DEFAULT_RANGE)
            keys = _extract_expiry_keys(chain)
            expiry_key = _pick_expiry(keys, dte=dte, mode=expiry_mode)

        snap = _compute_snapshot(symbol=symbol, expiry_key=expiry_key, strike_count=strike_count)
        return snap

    except Exception as e:
        msg = str(e) or "Internal error"
        return JSONResponse(status_code=500, content={"live": False, "error": msg})

root@vultr:~/ironcondor#
root@vultr:~/ironcondor#
root@vultr:~/ironcondor# cat landscape.html
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1"/>
  <title>Landscape</title>

  <style>
    :root{
      --bg:#070b12;
      --panel:#0b1220;
      --border:rgba(255,255,255,.08);
      --muted:rgba(255,255,255,.65);
      --text:rgba(255,255,255,.92);

      --green:#22c55e;
      --red:#ef4444;
      --purple:#7c3aed;

      --shadow: 0 20px 60px rgba(0,0,0,.55);
      --radius: 18px;
    }
    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial;
      color:var(--text);
      background: radial-gradient(1200px 700px at 30% 15%, rgba(40,180,120,.16), transparent 55%),
                  radial-gradient(900px 600px at 75% 30%, rgba(130,70,255,.18), transparent 55%),
                  radial-gradient(800px 500px at 60% 80%, rgba(255,70,70,.14), transparent 60%),
                  var(--bg);
    }

    .app{
      height:100vh;
      padding:16px;
      display:grid;
      grid-template-columns: 290px 1fr 320px;
      gap:16px;
    }
    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
      border:1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      min-height:0;
    }

    /* Left controls */
    .left{
      padding:16px;
      display:flex;
      flex-direction:column;
      gap:12px;
      min-height:0;
    }
    .titleRow{
      display:flex;
      justify-content:space-between;
      align-items:center;
      padding-bottom:6px;
      border-bottom:1px solid var(--border);
    }
    .titleRow .t{font-weight:700;letter-spacing:.2px;}
    .sub{font-size:12px;color:var(--muted);margin-top:2px;}
    .btnTop{
      display:inline-flex;gap:8px;align-items:center;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      color:var(--text);
      border-radius:999px;
      padding:8px 10px;
      cursor:pointer;
      text-decoration:none;
      font-size:12px;
    }
    .btnTop:hover{background: rgba(255,255,255,.07);}
    label{font-size:12px;color:var(--muted);display:block;margin:6px 0 6px;}
    input, select{
      width:100%;
      border-radius:12px;
      border:1px solid var(--border);
      background: rgba(0,0,0,.25);
      color:var(--text);
      padding:10px 12px;
      outline:none;
    }
    .row2{display:grid;grid-template-columns: 1fr 1fr;gap:10px;}
    .btn{
      margin-top:6px;width:100%;
      border:none;border-radius:14px;
      padding:12px 12px;
      font-weight:700;color:white;
      cursor:pointer;
      background: linear-gradient(180deg, rgba(60,140,255,.95), rgba(20,90,220,.95));
      box-shadow: 0 10px 30px rgba(10,90,220,.35);
    }
    .btn:disabled{opacity:.6;cursor:not-allowed}
    .pills{display:flex;flex-wrap:wrap;gap:8px;align-items:center;margin-top:2px;}
    .pill{
      font-size:12px;border:1px solid var(--border);
      border-radius:999px;padding:6px 10px;
      background: rgba(255,255,255,.04);
      color:var(--text);
      display:inline-flex;gap:6px;align-items:center;
    }
    .dot{width:8px;height:8px;border-radius:50%;background: rgba(255,255,255,.5);}
    .dot.green{background: var(--green);}
    .dot.red{background: var(--red);}
    .dot.neutral{background: rgba(255,255,255,.55);}

    details{border:1px solid var(--border);border-radius:14px;background: rgba(0,0,0,.18);overflow:hidden;}
    summary{cursor:pointer;padding:10px 12px;font-weight:700;color:var(--text);list-style:none;}
    summary::-webkit-details-marker{display:none}
    .faqBody{padding:0 12px 12px;color:var(--muted);font-size:12px;line-height:1.35;}

    /* Center */
    .center{padding:14px 14px 10px;display:flex;flex-direction:column;gap:10px;min-height:0;}
    .centerHeader{
      display:flex;align-items:flex-start;justify-content:space-between;gap:12px;
      padding:4px 2px 8px;border-bottom:1px solid var(--border);
    }
    .centerHeader h2{margin:0;font-size:18px;letter-spacing:.2px;}
    .centerHeader .hint{margin-top:2px;font-size:12px;color:var(--muted);}
    .spotBadge{display:flex;gap:10px;align-items:center;justify-content:flex-end;}
    .spotBadge .spotPill{
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      border-radius:999px;padding:6px 10px;
      font-size:12px;color:var(--text);
    }

    .domWrap{display:flex;flex-direction:column;gap:6px;align-items:flex-end;}
    .domBadge{
      border-radius:999px;padding:7px 10px;font-size:12px;font-weight:800;
      border:1px solid var(--border);
      background: rgba(255,255,255,.04);
      display:inline-flex;gap:8px;align-items:center;white-space:nowrap;
    }
    .domBadge.call{border-color: rgba(34,197,94,.35); background: rgba(34,197,94,.10);}
    .domBadge.put{border-color: rgba(239,68,68,.35); background: rgba(239,68,68,.10);}
    .domBadge.mixed{border-color: rgba(255,255,255,.20); background: rgba(255,255,255,.05);}
    .domMini{font-size:11px;color:var(--muted);text-align:right;max-width:280px;}

    .scrollArea{flex:1;min-height:0;overflow:auto;padding-right:6px;}
    .twoCols{display:grid;grid-template-columns: 300px 1fr;gap:14px;align-items:start;}

    .subCard{border:1px solid var(--border);border-radius:16px;background: rgba(0,0,0,.18);overflow:hidden;min-height:0;}
    .subCardHead{
      display:flex;justify-content:space-between;align-items:center;
      padding:10px 12px;border-bottom:1px solid var(--border);
      color:var(--muted);font-size:12px;
    }
    .subCardBody{padding:10px 10px 12px;}

    .bars{display:flex;flex-direction:column;gap:8px;}
    .barRow{display:grid;grid-template-columns: 54px 1fr;gap:10px;align-items:center;font-variant-numeric: tabular-nums;}
    .barStrike{font-weight:700;color:rgba(255,255,255,.85);text-align:right;}
    .barTrack{
      position:relative;height:12px;border-radius:999px;background: rgba(255,255,255,.05);
      overflow:hidden;border:1px solid rgba(255,255,255,.06);
    }
    .barFill{position:absolute;top:0;bottom:0;left:50%;transform-origin:left;}
    .barFill.pos{left:50%;}
    .barFill.neg{right:50%;left:auto;transform-origin:right;}
    .barFill.netPos{background: var(--green);opacity:.9;}
    .barFill.netNeg{background: var(--red);opacity:.9;}
    .barFill.purple{background: var(--purple);opacity:.45;top:2px;bottom:2px;border-radius:999px;}

    table{width:100%;border-collapse:collapse;font-variant-numeric: tabular-nums;}
    thead th{
      text-align:left;font-size:12px;color:var(--muted);
      padding:10px 10px;border-bottom:1px solid var(--border);
      position:sticky;top:0;background: rgba(0,0,0,.35);
      backdrop-filter: blur(10px);z-index:2;
    }
    tbody td{
      padding:9px 10px;border-bottom:1px solid rgba(255,255,255,.06);
      font-size:12.5px;color:rgba(255,255,255,.9);
    }
    tbody tr:hover td{background: rgba(255,255,255,.03);}
    .numPos{color: rgba(34,197,94,.95); font-weight:700;}
    .numNeg{color: rgba(239,68,68,.95); font-weight:700;}

    .spotRow td{background: rgba(56,189,248,.10);border-bottom-color: rgba(56,189,248,.22);}
    .spotRow td:first-child{position:relative;}
    .spotRow td:first-child:before{
      content:"";position:absolute;left:0;top:0;bottom:0;width:3px;
      background: rgba(56,189,248,.9);border-radius:2px;
    }

    /* Right */
    .right{padding:14px;display:flex;flex-direction:column;gap:10px;min-height:0;}
    .right h3{margin:2px 2px 0;font-size:16px;}
    .right .hint{margin:0 2px 8px;color:var(--muted);font-size:12px;}
    .kv{
      display:grid;grid-template-columns: 1fr auto;gap:10px;
      padding:10px 12px;border:1px solid var(--border);
      border-radius:14px;background: rgba(0,0,0,.18);
      font-size:12px;align-items:center;
    }
    .kv .k{color:var(--muted)}
    .kv .v{font-weight:800}
    .section{margin-top:8px;padding-top:10px;border-top:1px solid var(--border);}
    .sectionTitle{font-size:12px;font-weight:800;color:rgba(255,255,255,.85);margin:0 2px 6px;}
    .smallTable thead th{font-size:11px}
    .smallTable tbody td{font-size:11.5px}

    .scrollArea::-webkit-scrollbar{width:10px}
    .scrollArea::-webkit-scrollbar-thumb{
      background: rgba(255,255,255,.10);
      border-radius:999px;border:2px solid rgba(0,0,0,.25);
    }
  </style>
</head>

<body>
  <div class="app">

    <!-- LEFT -->
    <div class="panel left">
      <div class="titleRow">
        <div>
          <div class="t">Controls</div>
          <div class="sub">Landscape</div>
        </div>
        <a class="btnTop" href="/" title="Back to Dashboard">← Dashboard</a>
      </div>

      <div>
        <label>Symbol</label>
        <input id="symbol" value="$SPX"/>
      </div>

      <div class="row2">
        <div>
          <label>DTE</label>
          <input id="dte" type="number" value="0" min="0" step="1"/>
        </div>
        <div>
          <label>Strike Count</label>
          <input id="strikeCount" type="number" value="60" min="10" step="5"/>
        </div>
      </div>

      <div>
        <label>Expiry (dropdown)</label>
        <select id="expirySelect">
          <option value="">Loading expiries…</option>
        </select>
        <div style="font-size:11px;color:var(--muted);margin-top:6px;">
          Tip: choose an expiry from the list to minimize API usage.
        </div>
      </div>

      <button id="refreshBtn" class="btn">Refresh</button>

      <div class="pills">
        <span class="pill"><span id="liveDot" class="dot neutral"></span> Live: <b id="liveTxt">—</b></span>
        <span class="pill">Updated: <b id="updTxt">—</b></span>
      </div>

      <details open>
        <summary>FAQ (Landscape)</summary>
        <div class="faqBody">
          <b>Green vs Red bars:</b> Net OI proxy (Calls − Puts).<br/>
          <b>Purple overlay:</b> Total OI concentration (bigger purple = heavier OI).<br/><br/>
          <b>Domination badge:</b> uses zone logic:
          below-spot “call share” vs above-spot “put share”, to reduce single-strike noise.<br/><br/>
          <b>Unusual table:</b> near-spot strikes ranked by Vol/OI (top 10).
        </div>
      </details>
    </div>

    <!-- CENTER -->
    <div class="panel center">
      <div class="centerHeader">
        <div>
          <h2>Strike Ladder</h2>
          <div class="hint">Histogram (left) + dominance table (right)</div>
        </div>

        <div class="domWrap">
          <div class="spotBadge">
            <div class="spotPill">Spot: <b id="spotTop">—</b></div>
            <div id="domBadge" class="domBadge mixed"><span class="dot neutral"></span> Mixed / Transition</div>
          </div>
          <div id="domMini" class="domMini">Below: — • Above: —</div>
        </div>
      </div>

      <div class="scrollArea">
        <div class="twoCols">
          <div class="subCard">
            <div class="subCardHead">
              <div>Net OI Bars</div>
              <div id="barCount" style="color:var(--muted)">—</div>
            </div>
            <div class="subCardBody">
              <div id="bars" class="bars"></div>
            </div>
          </div>

          <div class="subCard">
            <div class="subCardHead">
              <div>Strike Table</div>
              <div id="strikeMeta" style="color:var(--muted)">—</div>
            </div>
            <div class="subCardBody" style="padding:0">
              <table id="strikeTable">
                <thead>
                  <tr>
                    <th style="width:90px">Strike</th>
                    <th style="width:90px">Net OI</th>
                    <th style="width:120px">Total OI</th>
                    <th style="width:110px">% From Spot</th>
                  </tr>
                </thead>
                <tbody id="tbody"></tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="panel right">
      <div>
        <h3>Levels</h3>
        <div class="hint">Summary + Unusual Vol/OI (near spot)</div>
      </div>

      <div class="kv"><div class="k">Symbol</div><div class="v" id="lvSymbol">—</div></div>
      <div class="kv"><div class="k">Expiry</div><div class="v" id="lvExpiry">—</div></div>
      <div class="kv"><div class="k">Spot</div><div class="v" id="lvSpot">—</div></div>
      <div class="kv"><div class="k">Expected Move</div><div class="v" id="lvEM">—</div></div>
      <div class="kv"><div class="k">EM Range</div><div class="v" id="lvRange">—</div></div>
      <div class="kv"><div class="k">Zero Pivot</div><div class="v" id="lvZero">—</div></div>
      <div class="kv"><div class="k">Call Wall</div><div class="v" id="lvCallWall">—</div></div>
      <div class="kv"><div class="k">Put Wall</div><div class="v" id="lvPutWall">—</div></div>

      <div class="section">
        <div class="sectionTitle">Unusual Vol/OI (near spot)</div>
        <table class="smallTable">
          <thead>
            <tr>
              <th>Strike</th><th>Type</th><th>Vol</th><th>OI</th><th>Vol/OI</th><th>Dist</th><th>Pressure</th>
            </tr>
          </thead>
          <tbody id="unusualBody">
            <tr><td colspan="7" style="color:var(--muted);padding:10px 6px;">—</td></tr>
          </tbody>
        </table>
      </div>
    </div>

  </div>

  <script>
    const $ = (id) => document.getElementById(id);

    function fmtNum(x){
      if (x === null || x === undefined || Number.isNaN(x)) return "—";
      const abs = Math.abs(x);
      if (abs >= 1e9) return (x/1e9).toFixed(2) + "B";
      if (abs >= 1e6) return (x/1e6).toFixed(2) + "M";
      if (abs >= 1e3) return (x/1e3).toFixed(2) + "K";
      if (abs >= 100) return String(Math.round(x));
      return String(x.toFixed ? x.toFixed(2) : x);
    }
    function fmtPct(x){
      if (x === null || x === undefined || Number.isNaN(x)) return "—";
      return (x*100).toFixed(0) + "%";
    }
    function setDot(el, mode){
      el.classList.remove("green","red","neutral");
      el.classList.add(mode);
    }

    function buildRowsFromMVP(data){
      const strikes = (data?.histogram?.strikes || []);
      const netArr  = (data?.histogram?.gex_oi || []);
      const spot = Number(data?.spot);

      const rows = [];
      for (let i=0;i<strikes.length;i++){
        const s = Number(strikes[i]);
        const net = Number(netArr[i] ?? 0);
        const total = Math.abs(net);  // proxy for purple bar size
        const dist = (spot && isFinite(spot)) ? ((s-spot)/spot) : null;
        rows.push({ strike:s, net_oi: net, total_oi: total, dist });
      }
      return rows;
    }

    function computeDominance(rows, spot){
      const below = rows.filter(r => r.strike < spot);
      const above = rows.filter(r => r.strike > spot);
      const belowCount = Math.max(below.length, 1);
      const aboveCount = Math.max(above.length, 1);

      const belowCallShare = below.filter(r => r.net_oi > 0).length / belowCount;
      const abovePutShare  = above.filter(r => r.net_oi < 0).length / aboveCount;

      let label = "Mixed / Transition";
      let cls = "mixed";
      let dot = "neutral";

      if (belowCallShare >= 0.60 && abovePutShare <= 0.40){
        label = "CALL Dominated"; cls = "call"; dot = "green";
      } else if (abovePutShare >= 0.60 && belowCallShare <= 0.40){
        label = "PUT Dominated"; cls = "put"; dot = "red";
      }
      return { belowCallShare, abovePutShare, label, cls, dot };
    }

    function renderDominance(dom){
      const badge = $("domBadge");
      badge.classList.remove("call","put","mixed");
      badge.classList.add(dom.cls);
      badge.innerHTML = `<span class="dot ${dom.dot}"></span> ${dom.label}`;
      $("domMini").textContent = `Below spot: ${fmtPct(dom.belowCallShare)} calls • Above spot: ${fmtPct(dom.abovePutShare)} puts`;
    }

    function renderBars(rows){
      const el = $("bars");
      el.innerHTML = "";
      const maxAbs = Math.max(...rows.map(r => Math.abs(r.net_oi)), 1);
      const maxTot = Math.max(...rows.map(r => r.total_oi || 0), 1);
      const sorted = [...rows].sort((a,b)=>a.strike-b.strike);

      for (const r of sorted){
        const row = document.createElement("div");
        row.className = "barRow";

        const st = document.createElement("div");
        st.className = "barStrike";
        st.textContent = String(r.strike.toFixed(0));

        const track = document.createElement("div");
        track.className = "barTrack";
        track.title = `Strike ${r.strike}\nNet OI: ${fmtNum(r.net_oi)}\nTotal OI: ${fmtNum(r.total_oi)}\nDist: ${r.dist!==null? (r.dist*100).toFixed(2)+"%":"—"}`;

        const w = Math.min(Math.abs(r.net_oi)/maxAbs, 1) * 50;
        const fill = document.createElement("div");
        fill.className = "barFill " + (r.net_oi >= 0 ? "pos netPos" : "neg netNeg");
        fill.style.width = w + "%";
        fill.style.borderRadius = "999px";

        const pw = Math.min((r.total_oi || 0)/maxTot, 1) * 50;
        const purple = document.createElement("div");
        purple.className = "barFill purple " + (r.net_oi >= 0 ? "pos" : "neg");
        purple.style.width = pw + "%";

        track.appendChild(fill);
        track.appendChild(purple);

        row.appendChild(st);
        row.appendChild(track);
        el.appendChild(row);
      }
      $("barCount").textContent = `${rows.length} strikes`;
    }

    function renderStrikeTable(rows, spot){
      const tb = $("tbody");
      tb.innerHTML = "";
      const sorted = [...rows].sort((a,b)=>a.strike-b.strike);

      // spot highlight = closest strike
      let closest = sorted[0]?.strike ?? null;
      let bestD = Infinity;
      for (const r of sorted){
        const d = Math.abs(r.strike - spot);
        if (d < bestD){ bestD = d; closest = r.strike; }
      }

      for (const r of sorted){
        const tr = document.createElement("tr");
        if (closest !== null && r.strike === closest) tr.classList.add("spotRow");
        const netClass = (r.net_oi >= 0) ? "numPos" : "numNeg";
        const distTxt = (r.dist!==null && isFinite(r.dist)) ? ((r.dist*100).toFixed(2)+"%") : "—";

        tr.innerHTML = `
          <td>${r.strike.toFixed(0)}</td>
          <td class="${netClass}">${(r.net_oi>=0?"+":"") + fmtNum(r.net_oi)}</td>
          <td>${fmtNum(r.total_oi)}</td>
          <td>${distTxt}</td>
        `;
        tb.appendChild(tr);
      }
      $("strikeMeta").textContent = `Spot-highlight: ${closest!==null ? closest.toFixed(0) : "—"}`;
    }

    function renderLevels(data){
      $("lvSymbol").textContent = data?.symbol ?? "—";
      $("lvExpiry").textContent = data?.expiry ?? "—";
      $("lvSpot").textContent = (data?.spot!=null) ? Number(data.spot).toFixed(2) : "—";
      $("lvEM").textContent = (data?.expected_move!=null) ? "± " + Number(data.expected_move).toFixed(2) : "—";
      const lo = data?.em_lower, hi = data?.em_upper;
      $("lvRange").textContent = (lo!=null && hi!=null) ? `${Number(lo).toFixed(2)} → ${Number(hi).toFixed(2)}` : "—";
      $("lvZero").textContent = (data?.zero_gamma!=null) ? Number(data.zero_gamma).toFixed(2) : "—";
      $("lvCallWall").textContent = (data?.call_wall!=null) ? Number(data.call_wall).toFixed(2) : "—";
      $("lvPutWall").textContent = (data?.put_wall!=null) ? Number(data.put_wall).toFixed(2) : "—";
    }

    function renderUnusual(data){
      const list = data?.unusual || [];
      const body = $("unusualBody");
      body.innerHTML = "";
      if (!list.length){
        body.innerHTML = `<tr><td colspan="7" style="color:var(--muted);padding:10px 6px;">—</td></tr>`;
        return;
      }
      for (const u of list){
        const tr = document.createElement("tr");
        tr.innerHTML = `
          <td>${u.strike ?? "—"}</td>
          <td>${u.type ?? "—"}</td>
          <td>${u.vol ?? "—"}</td>
          <td>${u.oi ?? "—"}</td>
          <td>${u.vol_oi ?? "—"}</td>
          <td>${u.dist ?? "—"}</td>
          <td>${u.pressure ?? "—"}</td>
        `;
        body.appendChild(tr);
      }
    }

    async function loadExpiries(){
      const symbol = encodeURIComponent($("symbol").value.trim() || "$SPX");
      const sel = $("expirySelect");
      sel.innerHTML = `<option value="">Loading expiries…</option>`;
      try{
        const res = await fetch(`/api/expiries?symbol=${symbol}&limit=8`, {cache:"no-store"});
        const j = await res.json();
        if(!res.ok) throw new Error(JSON.stringify(j));

        const expiries = j.expiries || [];
        if(!expiries.length){
          sel.innerHTML = `<option value="">No expiries</option>`;
          return;
        }

        sel.innerHTML = expiries.map(e => `<option value="${e}">${e}</option>`).join("");

        // default: pick first expiry
        sel.value = expiries[0];
      }catch(e){
        sel.innerHTML = `<option value="">(failed to load)</option>`;
        console.error("expiries load failed", e);
      }
    }

    async function loadMVP(){
      const btn = $("refreshBtn");
      btn.disabled = true;
      btn.textContent = "Loading...";

      const symbol = encodeURIComponent($("symbol").value.trim() || "$SPX");
      const dte = Number($("dte").value || 0);
      const strikeCount = Number($("strikeCount").value || 60);
      const expiry = $("expirySelect").value || "";

      try{
        // dropdown-only mode:
        // if expiry is present, pass expiry=... so backend does NOT guess
        const qs = expiry
          ? `symbol=${symbol}&expiry=${encodeURIComponent(expiry)}&dte=${dte}&strike_count=${strikeCount}`
          : `symbol=${symbol}&dte=${dte}&strike_count=${strikeCount}&expiry_mode=closest`;

        const res = await fetch(`/api/mvp?${qs}`, { cache: "no-store" });
        const data = await res.json();
        if (!res.ok){
          alert(`API error ${res.status}: ${JSON.stringify(data)}`);
          return;
        }

        $("liveTxt").textContent = data?.live ? "YES" : "NO";
        setDot($("liveDot"), data?.live ? "green" : "neutral");
        $("updTxt").textContent = new Date().toLocaleTimeString();

        const spot = Number(data?.spot);
        $("spotTop").textContent = isFinite(spot) ? spot.toFixed(2) : "—";

        const rows = buildRowsFromMVP(data);
        const dom = (isFinite(spot) && rows.length) ? computeDominance(rows, spot) : {
          belowCallShare: NaN, abovePutShare: NaN, label: "Mixed / Transition", cls:"mixed", dot:"neutral"
        };

        renderDominance(dom);
        renderBars(rows);
        renderStrikeTable(rows, spot);

        renderLevels(data);
        renderUnusual(data);

      }catch(e){
        alert("Error: " + (e?.message || String(e)));
      }finally{
        btn.disabled = false;
        btn.textContent = "Refresh";
      }
    }

    $("refreshBtn").addEventListener("click", loadMVP);

    $("symbol").addEventListener("change", async ()=>{
      await loadExpiries();
      await loadMVP();
    });

    $("expirySelect").addEventListener("change", async ()=>{
      await loadMVP();
    });

    (async ()=>{
      await loadExpiries();
      await loadMVP();
    })();
  </script>
</body>
</html>

